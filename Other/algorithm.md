# 序章

思考に道筋

- 規則性を考える
- いくつかの簡単な問題に分解する
- 条件を適切に言い換える
- 状態数を考える

## 変換

### ２進法 →10 進法

位が繰り上がる数をその数にかけていく。1011 という 2 進法で考える。
`(1*8) + (0*4) + (2*1) + (1*1) = 11`

### 10 進法 → ２進法

数がゼロになるまで２で割った余りを計算し、下の位から読む。11 という 10 進法で考える。表記は`a / b = c(a/b)...d(a%b)`。

```
11 / 2 = 5..1
5 / 2 = 2..1
2 / 2 = 1..0
1 / 2 = 0..1
```

上記の余の部分を下から数えると、`1011`となる。

## 基本的な演算と記号

- 剰余(mod)
  - a mod b
- 絶対値(abs)
  - |a|
- 累乗(pow)
  - $a^{b}$
  - $a^{-b}$
    - $1/a^{b}$
- ルート(sprt)
  - $\sqrt{4}$ = 2
  - $\sqrt[3]{8}$ = 2

### 論理演算

- a AND b
  - a,b の両方が true であれば true
- a OR b
  - a,b のうち少なくとも一方だけが true であれば true
- a XOR b
  - a,b のうち一方だけが true であれば true
    - a=true, b=true だと結果は false

### ビット演算

1.  整数を２進法へ変換
2.  桁ごとに論理演算を行う
3.  論理演算の結果を整数に変換

※true=1, false=0

`11 AND 14`の場合,`1011`,`1110`の比較になり桁ごとの比較は１桁目からでいうと`0101`になり上から数えると`1010`で、これを整数に治すと 10 である。よって`11 AND 14 = 10`である。

`11 OR 14`の場合、お互いに 0 でないなら 1 なので`1111`となり、`11 OR 14 = 15`となる。

`11 XOR 14`の場合、`1010`となり１桁目から数えると`0101`で`11 XOR 14 = 5`となる。

| AND  | OR   | XOR  |
| :--- | :--- | :--- |
| `&`  | `\|` | `^`  |

```js
const a = 11 & 14; //10
const b = 11 | 14; //15
const c = 11 ^ 14; //5
```

#### 3 つ以上の整数に対する演算

`a AND b AND c`のような場合、2 つに対してビット演算`a AND b`し、次に残りの値に対して演算`(a AND b) AND c`する。

```
(11 AND 27) AND 40
= 11 AND 40
= 8
```

### 左シフト、右シフト

左シフト演算、右シフト演算は整数 a,b に対する演算であり、a を 2 進法で表した時のビットを b 個、左か右にずらすもの。また`1 << N`は$2^N$を表す。

```js
const a = 5; // 00000000000000000000000000000101
const b = 2; // 00000000000000000000000000000010

console.log(a << b); // 00000000000000000000000000010100
// expected output: 20
```

## 関数

- 一次関数
  - $y=x$
- 二次関数
- - $y=x^{2}$
- 多項式関数
  - $y=x^{2}$, $y=x^{3}$
  - 多項式
    - $x^{2}$
- [単項式]$y=x^{2}$
- [not 単項式] $y=x^{2}+2x$
- [k 次の項]$y=x^{k}$
- $y=x^{2}+9[⇦定数項]$

### べき乗の拡張

- $a^{-n}$ = $1/a^{n}$
  - $10^{-2}=1/100$
- $a^{n/m} = \sqrt[m]{a^{n}}$
  - $32^{0.4} = \sqrt[5]{32^{2}} = 4$

### 指数関数

$y=a^{x}$

### 対数関数

$log{_a}{b}$ は a を何乗したら b になるか。

- $log{_2}{1} = 0$
- $log{_2}{2} = 1$
- $log{_2}{4} = 2$

[**log の公式**](https://sci-pursuit.com/math/logarithm-formulae-and-calculation.html)

### その他

- 床関数$\lfloor x \rfloor$
  - x 以下で最大の整数 y を変える関数
    - $\lfloor 6.5 \rfloor$=6, $\lfloor 10 \rfloor$=10, $\lfloor -2.1 \rfloor$=-3,
- 天井関数$\lceil x \rceil$
  - x 以上で最小の整数 y を変える関数
    - $\lceil 6.5 \rceil$=7, $\lceil 10 \rceil$=10, $\lceil -2.1 \rceil$=-2,

# [desmos.com](https://www.desmos.com/calculator)で表見ながら遊べるらしい。

# 計算量

$
O(N!) > O(4^{n}) > O(3^{n}) > O(N^{2}2^{n}) > O(N2^{n}) > O(2^{n}) > O(1.1^{n}) > O(N^{99}) > O(N^{5}) > O(N^{4})> O(N^{2})> O(N^{1.5})> O(Nlog{N}) > O(N) > O(\sqrt{N}) > O(log{N}) > O(1)
$

## その他の基本的な数学知識

- 素数
  - 1 と自分指針以外で割り切れない２以上の整数。2,3,5,7,11,13,17...
- 最大公約数
  - 6,9=>3
- 最小公倍数
  - 6,9=>18

$$
(A,Bの最小公倍数) = \frac{AB}{A,Bの最大公約数}
$$

上記の場合、$6 \times 9 = 3 \times 18$が成り立つ

- 階乗
  - 3! => $3 \times 2 \times 1$

### 集合

- 空集合`{}`
  - 何も含まれていない集合
- 帰属関係$x \in A$
  - 集合 A に要素 x が含まれていること
- 集合 A の要素数`|A|`
- 積集合$A \cap B$
  - 共通部分
- 和集合$A \cup B$
  - 少なくとも一方に含まれる部分
- 部分集合
  - A は B の部分集合 $A \subset B$

### 必要条件と十分条件

- ある条件 X を満たすために
  - 絶対に条件 A を満たす必要がある場合、A は必要条件
  - 条件 A さえ満たせば条件 X を満たす場合、A は十分条件

条件 X・・・N が３以上の素数である
N が奇数であること・・・必要条件
N が 5 or 11 であること・・・十分条件

### 絶対誤差と相対誤差

- 絶対誤差$|a-b|$
- 相対誤差$|a-b/b|$

### 閉区間、開区間、半開区間

- [l,r]
  - l 以上 r 以下
- [l,r)
  - l 以上 r 未満
- (l,r]
  - l より大きく r 以下
- (l,r)
  - l より大きく r 未満

### シグマ

$A_{L} + A_{L+1} + ... + A_{R} = \sum_{i=L}^{R}A_{i}$

$\sum_{i=1}^{N}i = \frac{N \times (N+1)}{2}$

$\sum_{i=1}^{N}i^{2} = \frac{N \times (N+1) \times (2N+1)}{6}$

<br/>
<br/>
<br/>

# ビット演算しんどい

[参考 Qiita](https://qiita.com/drken/items/7c6ff2aa4d8fce1c9361)

| やりたいこと                                     | 実装                      |
| ------------------------------------------------ | ------------------------- |
| ビット bit に i 番目のフラグが立っているかどうか | if (bit & (1<<i))         |
| ビット bit に i 番目のフラグが消えているかどうか | if (!(bit & (1<<i)))      |
| ビット bit に i 番目のフラグを立てる             | bit ｜= (1<<i)            |
| ビット bit に i 番目のフラグを消す               | bit &= ~(1<<i)            |
| ビット bit に何個のフラグが立っているか          | \_\_builtin_popcount(bit) |
| ビット bit に i 番目のフラグを立てたもの         | bit ｜(1<<i)              |
| ビット bit に i 番目のフラグを消したもの         | bit & ~(1<<i)             |

`~`は 0=>1, 1=>0 と逆（否定）にする。

**２進法で計算可能な場合はビット演算を用いると良さそう**

# 基本的なアルゴリズム

## 素数判定

$\lfloor\sqrt{N}\rfloor$まで調べて割り切れなければ素数である。

## ユークリッド互除法

1. 大き方の数を「大きい方を小さい方で割った余り」に書き換えるという操作を繰り返す
2. 片方がゼロになったら終了で、片方の数字が最大公約数である

最小公倍数は下記で求められる。

$$
(A,Bの最小公倍数) = \frac{AB}{A,Bの最大公約数}
$$

## 場合の数

#### N 通りと M 通りの事柄の組み合わせは MN

#### M 通りの選択肢が考えられる事柄が N 子あるような組み合わせは$M^{N}$

#### 全ての要素が 1or2 である N 個の選び方は$2^{N}$

#### n 個のものを並び替える方法は$n!$

#### n 個のものから r 個を並べる方法は$_{n}P_{r} = \frac{n!}{(n-r)!}$

#### n 個のものから r 個を選ぶ方法は$_{n}C_{R} = \frac{n!}{r!(n-r)!}$

<br/>
<br/>
<br/>

## 確率・期待値とアルゴリズム

### 確率$\frac{N}{M}$

### 期待値は、１回の試行で得られる平均的な値のこと

ある試行を行った結果として N このパターンが考えられ、i 番目の結果$x_{i}$が起こる確率を$p_{i}$とすると、$\sum_{i=1}^{N}p_{i}x_{i}$で表せる。

## モンテカルロ法

- 平均値 μ（ミュー）：データの平均的な値
- 標準偏差 σ（シグマ）：データの散らばり具合

- μ-σ 以上,μ+σ 以下の範囲に全体の約 68%が含まれる
- μ-2σ 以上,μ+2σ 以下の範囲に全体の約 95%が含まれる
- μ-3σ 以上,μ+3σ 以下の範囲に全体の約 99.7%が含まれる

## ソートと再帰の考え方

### 選択ソート

選択ソートはまだ調べていない中で最も小さい数を探すことを繰り返して(前に持って行き)、配列をソートする手法です。

### 再帰

アルゴリズムなどは記述する際に、自分自身を引用する形で定義することを再起的定義という。
再帰関数は便利だが、条件などを間違うと無限ループする可能性もあるので注意。

### マージソート

$O(NlogN)$

![merge-sort](https://user-images.githubusercontent.com/46220963/172806623-97da0400-4ebd-42b2-864a-fb0b826a1d49.png)

- 挿入ソート
  - 最悪ケースで$O(N^{2})$で余り効率的でない
- クイックソート
  - 実用上最も高速とされるソートアルゴリズム$O(NlogN)$
- 計算ソート
  - O(N+B)で値が小さい配列に対しては有効

## 動的計画法〜漸化式の利用〜

数列において、前の項の結果からその項の値を求める規則のことを漸化式と言います。

### 等差数列

$a_{1} = 1$

$a_{n} = a_{n-1}+2(n >= 2)$

### フィボナッチ数列

直前の項の結果だけでなく、2 つ以上前の項の結果を利用することもあります。

$a_{1} = 1, a_{2} = 2$

$a_{n} = a_{n-1}+a_{n-2}(n >= 3)$

1,1,2,3,5,8,13 のように前の 2 つの項を足した数がくる場合など...

### 動的計画法

「数列の漸化式のように、小さい問題の結果を利用して解くアルゴリズム」のことを指します。

dp[0] = 0 のように...(問題のイメージがないと分かりにくいので割愛)
